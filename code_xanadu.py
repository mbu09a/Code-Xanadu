"""
code_xanadu.py – Prompt‑compiler **and** Codex‑Cloud bootstrapper for the Gibsey stack
────────────────────────────────────────────────────────────────────────────
This single script now handles three workflows:

1. **build**  – Concatenate your layered YAML scaffold into `build/compiled_prompt.txt`.
2. **run**    – Spawn a local **codex‑cli** REPL pre‑seeded with that prompt (good for fast iteration).
3. **submit** – Fire a long‑running *cloud* Codex task against your Git repo, injecting the same
                prompt so the remote agent has full QDPI context.
4. **watch**  – Poll Codex Cloud for job status/logs.

It expects a modern Codex Cloud preview (May‑2025+) where jobs are created via
`POST /v1/codex/jobs` and streamed from `GET /v1/codex/jobs/{id}`.

Requires:
    pip install pyyaml rich requests

Env vars:
    OPENAI_API_KEY   – your bearer token
    CODEX_MODEL      – default codex‑1 (override as needed)
    GIBSEY_DIR       – path to the Gibsey repo root
    GIT_REPO         – full HTTPS URL of the repo (for cloud jobs)

Usage examples:
    python code_xanadu.py build
    python code_xanadu.py run
    python code_xanadu.py submit "Add QDPI tool schema to prompts/tools.yaml"
    python code_xanadu.py watch <job‑id>
"""
from __future__ import annotations

import os
import sys
import json
import time
import hashlib
import pathlib
import subprocess
from dataclasses import dataclass
from typing import List, Dict, Any, Optional

import yaml
import requests
from rich import print
from rich.table import Table

# ─────────────────────────────────────────────── CONFIG
ROOT = pathlib.Path(os.environ.get("GIBSEY_DIR", pathlib.Path.cwd()))
PROMPT_SRC = ROOT / "prompts"
BUILD_DIR  = ROOT / "build"
BUILD_DIR.mkdir(exist_ok=True)

LAYER_ORDER = [
    "behavior.yaml",   # voice / persona / refusal lattice
    "tools.yaml",      # QDPI JSON function schemas
    "artifacts.yaml",  # MIME‑types recognised by front‑end
    "safety.yaml",     # minimal harms filter
    "modes.yaml"       # reasoning templates (reason / index / dream)
]

CODEX_BASE_URL = "https://api.openai.com/v1/codex"
DEFAULT_MODEL  = os.getenv("CODEX_MODEL", "codex-1")
HEADERS        = {
    "Authorization": f"Bearer {os.environ.get('OPENAI_API_KEY', '')}",
    "OpenAI-Beta": "assistants=v2"
}

# ─────────────────────────────────────────────── PROMPT COMPILER
@dataclass
class Layer:
    name: str
    body: str

    def __str__(self):
        banner = f"# ==== {self.name.upper()} ===="
        return f"{banner}\n{self.body.strip()}\n"

def load_layers() -> List[Layer]:
    layers: List[Layer] = []
    for fname in LAYER_ORDER:
        path = PROMPT_SRC / fname
        if not path.exists():
            print(f"[yellow]• skipping missing layer:[/yellow] {fname}")
            continue
        layers.append(Layer(fname, path.read_text()))
    return layers


def compile_prompt(layers: List[Layer]) -> str:
    concatenated = "\n".join(str(l) for l in layers)
    checksum = hashlib.sha256(concatenated.encode()).hexdigest()[:8]
    header = (
        "# Gibsey QDPI • Compiled Prompt\n"
        f"# Build‑ID: {checksum}\n"
        "# (auto‑generated by code_xanadu.py)\n\n"
    )
    return header + concatenated

# ─────────────────────────────────────────────── CLI RUN (local codex‑cli)

def run_codex_cli(prompt: str, model: str = DEFAULT_MODEL):
    """Spawn codex‑cli REPL with prompt pre‑loaded."""
    try:
        cmd = ["codex", "repl", "--model", model, "--no-cache"]
        proc = subprocess.Popen(cmd, stdin=subprocess.PIPE, stdout=subprocess.PIPE, text=True)
        assert proc.stdin and proc.stdout
        proc.stdin.write("/system\n" + prompt + "\n")
        proc.stdin.flush()
        print("[bright_blue]› Codex‑CLI ready. Ctrl‑D to exit.[/bright_blue]")
        while True:
            user = input("[you] ▶ ")
            proc.stdin.write(user + "\n")
            proc.stdin.flush()
            for line in proc.stdout:
                if line.strip() == "(codex)":
                    break
                print(line.rstrip())
    except KeyboardInterrupt:
        print("\n[red]Session closed.[/red]")

# ─────────────────────────────────────────────── CLOUD JOB HELPERS

def submit_cloud_job(task_text: str, prompt: str, repo: Optional[str] = None, branch: str = "main") -> str:
    repo = repo or os.environ.get("GIT_REPO")
    if not repo:
        print("[red]GIT_REPO env var or --repo flag required for cloud jobs.[/red]")
        sys.exit(1)

    payload = {
        "model": DEFAULT_MODEL,
        "objective": task_text,
        "system_prompt": prompt,
        "repository": repo,
        "branch": branch,
        "timeout_minutes": 30
    }
    r = requests.post(f"{CODEX_BASE_URL}/jobs", headers=HEADERS, json=payload)
    r.raise_for_status()
    job_id = r.json()["id"]
    print(f"[green]✓ submitted job:[/green] {job_id}")
    return job_id


def poll_job(job_id: str, every: int = 10):
    url = f"{CODEX_BASE_URL}/jobs/{job_id}"
    while True:
        r = requests.get(url, headers=HEADERS)
        if r.status_code == 404:
            print("[red]job not found.[/red]")
            return
        data = r.json()
        status = data["status"]
        print(f"[cyan]{status}[/cyan] …", end="\r")
        if status in {"succeeded", "failed", "cancelled"}:
            break
        time.sleep(every)
    print()  # newline
    # pretty‑print summary table
    tbl = Table(title=f"Codex Job {job_id}")
    tbl.add_column("Key"); tbl.add_column("Value")
    for k in ("status", "duration_seconds", "branch", "commit_sha"):
        tbl.add_row(k, str(data.get(k)))
    print(tbl)
    # show logs
    logs = data.get("logs", "<no logs>")
    print("\n[bold]Logs:[/bold]\n" + logs)

# ─────────────────────────────────────────────── ENTRYPOINT
if __name__ == "__main__":
    if len(sys.argv) < 2 or sys.argv[1] not in {"build", "run", "submit", "watch"}:
        print("Usage: python code_xanadu.py [build|run|submit|watch]")
        sys.exit(1)

    cmd = sys.argv[1]
    layers = load_layers()
    compiled_prompt = compile_prompt(layers)

    if cmd == "build":
        out = BUILD_DIR / "compiled_prompt.txt"
        out.write_text(compiled_prompt)
        print(f"[green]✓ prompt built:[/green] {out}  ({len(compiled_prompt.split())} tokens)")
    elif cmd == "run":
        run_codex_cli(compiled_prompt)
    elif cmd == "submit":
        if len(sys.argv) < 3:
            print("[red]submit requires a task description argument.[/red]")
            sys.exit(1)
        task = " ".join(sys.argv[2:])
        job_id = submit_cloud_job(task, compiled_prompt)
        print(f"Run: python code_xanadu.py watch {job_id}")
    elif cmd == "watch":
        if len(sys.argv) < 3:
            print("[red]watch requires a job_id.[/red]")
            sys.exit(1)
        poll_job(sys.argv[2])